# dp求解最优答案
> 问题的关键很多都是决策的选取
> 决策定了状态也就定了
> 1.
> 当求解最优问题时，所有状态过多，我们可以先思考，最优的解法（或者之一）一定是有着怎么样结构（一般是贪心思想的发现）（可能有多个最优解，但有一个最优是这样构造的），之后我们可以按照这种结构（推导出递推）暴力去构造所有符合这个结构得到的答案之后取最优（即找到一个贪心的决策方式）
> （以上的想法减少了需要枚举的状态）
>2.
> 关于决策方式，有时会遇到多个个体的决策，他们之间决策互相影响，此时的最大问题就是当我们维护状态时，难以得知，他们已经进行的决策产生怎样的影响使得难以进行状态转移（因为我们不去记录决策（记录决策一般题目不要求我们不会去记录决策））这是我们应该去换一种决策方式（例如同时进行多个个体的决策，而非一个个体一个体的进行决策），使得不会产生决策影响的结果
> 例如：CF213C Relay Race，一个人走过的路程，会使权值变为零，当另外一个人再一次走到权值是零，而非初始值，当我们一个个体一个个体的决策时，势必会产生以上的影响导致我们无法状态转移，故我们的策略是使得两个人都各走一步，这时我们发现两个人产生路径重叠的情况只有可能是在状态转移的时候，而不可能出现状态转移时一个人走到了一个人曾经走过的地方（因为状态转移时都各走一步）
# 填表顺序
> 通过观察填表顺序，可以简化状态数，从而简化内存（这个只能优化内存对时间没有太大作用）
> 例如01背包的状态优化

> 其次有时候有些循环可以写成并列而非包含
# 一般下手策略
> 我们可以先尝试思考暴力枚举怎么做，然后思考怎么去优化，因为对于暴力枚举复杂度过高的原因基本就是因为重复操作过多，我们可以思考怎么利用历史操作去快速的得到当前状态的答案，来做到快速枚举的作用
# 贪心与dp的不同
> 贪心是我们一步一步的到达目标，而转移时我们只关注于上一步的最优，而非到达这一步所有的可能，dp则会记录到达这一步所有的可能
# 常见思维误区
> 我们常常把做纯贪心题目的思维移到dp题目上，即我们过度的想要放弃暴力枚举，转而去思考一些规模较大的复杂的最优策略，但是dp题应该是在一定的暴力基础上，通过贪心的状态转移，来实现枚举状态减少实现空间和时间的复杂度降低
# 状态转移的决策选择
有时状态转移的决策不能直接得到，这时我们可以利用线段树，单调队列来求得
CF1106E线段树维护决策
> 由该题纠正一个思维，我们可能无法通过build函数直接得到信息（因为build操作其实是单点操作，可能无法实现初始信息是区间信息的情况），我们可以假设一开始什么都没有，用区间修改操作来进行初始化
# 状态定义
> 有时状态定义需要有一位状态是极大的一个值，我们数组定义不可能有这么大空间，我们就思考能不能用类似离散化的思想，去找一个相对值（比如统一减去一个数，具体转移时再去加上这个数） 
# 状态转移
> 所谓的状态转移就是当前状态经过一步决策所能到达的状态，由该状态去更新能到达的状态，因为一步决策的简单性，我们可以从中思考出明显的优秀的策略
# wa的原因
> 1.循环范围太小（大不了直接上常数）
> 2. 答案筛选范围太小（大不了全搜）
# dp统计个数
> 此类问题做得少
> 向之前一样思考怎样完成这个问题（每一步的决策）
> 像函数变量一样的思考方式，当某些变量确定后，答案是一定的，由数值较小的变量向大变量转移
> dp求出能组成答案的某些集合，通过容斥原理等组合数学知识实现答案的统计
> # dp————状态与搜索的综合
> 对于题目的每一个状态都是一个节点，节点之间的边是状态转移的决策，这样构成了一个状态图
> 而状态的定义可以由贪心，思考对后继节点的影响相同等方式进行优化，减少节点数
> 而决策可以由数据结构，贪心等方式减少边的数量
> 递推写法本质上是bfs的搜索状态图
> 递归写法本质上是dfs的搜索状态图