# 线段树
## 理解
线段树区间操作能实现且复杂度能保持在 $\mathcal{O}(logn)$有以下几点
1. 能用线段树实现
   能用线段树实现的区间操作主要分两大类修改和查询
   1. 对于修改操作要求支持
      - 整体修改
  
        对于一个被操作区间完全覆盖的子区间，可以通过修改该子区间的若干区间信息来实现该区间的修改操作，不必再去访问该子区间的子节点
      - 操作合并
  
        能够将对同一区间的若干次整体修改操作用若干懒标储存下来(记录操作)，并能实现对子区间区间信息的修改和懒标下传(执行操作和操作合并，这是pushdown函数要干的事情)操作合并主要体现在懒标下传和记录操作
   2. 对于查询操作要求支持
      - 区间合并
  
        在一个区间的信息时可以由若干子区间的信息组成
> 注意就像上文提到一个线段树可能不止一个区间信息，也不止一个懒标，那么线段树代码难度主要体现在**区间合并操作和懒标下传操作** 
1. 复杂度保证
    按照线段树的区间划分方式，任意的一个区间最多可以分成$\mathcal{O}(logn)$个子区间
## Update函数
实现区间合并操作
## Pushdown函数
实现执行操作和操作合并
难点主要是可能有若干种不同的操作，每个操作之间会互相影响

一个隐藏的条件是lazy所代表的操作都是对整个区间的操作
## 关于区间信息的扩展
首先区间信息和合并一定得是常数级的，再次也得是$\mathcal{O}(logn)$级别

当我们发现所需区间信息是一个multiset的时候（允许重复元素的集合），而这个集合的大小能达到$\mathcal{O}(n)$，这是我们可以考虑设计哈希函数将n元向量映射，注意哈希值也要保证满足区间可合并性，甚至如果修改操作是区间修改，还需考虑哈希值要满足区间修改
## 动态开点线段树
此时一定不存在build的操作，故一般用于权值线段树上
在原来线段树基础上，递归到时先看子节点是否建立，如果不存在则动态开点，
