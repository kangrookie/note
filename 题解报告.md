# 卓班练习七
## 7.1 智能旅行规划
单源最短路板子题目，需要注意当 $dis_v=dis_u+val$时也需要对经过的城市数进行更新
下面是核心代码：
```
while(!q.empty()){
        int u=q.top().u,d=q.top().d;
        q.pop();
        if(d>dis[u])continue;
        for(auto v:ver[u]){
            if(dis[v.first]>dis[u]+v.second){
                dis[v.first]=dis[u]+v.second;
                num[v.first]=num[u]+1;
                q.push({v.first,dis[v.first]});
            }else if(dis[v.first]==dis[u]+v.second){
                num[v.first]=max(num[v.first],num[u]+1);
            }
        }
    }
```
这里的经过城市数其本质是记录决策
补充：
对于不同优化的dijkstra算法复杂度
朴素dijkstra复杂度为 $ \mathcal{O}(n^2) $
二叉堆优化复杂度为 $ \mathcal{O}((m+n)logn) $
优先队列优化复杂度为 $ \mathcal{O}((m+n)logm) $
斐波那契堆优化复杂度为 $ \mathcal{O}(m+nlogn) $
当n(点数),m(边数),是同一数据规模时后三种优化几乎没有区别，但是如果题目中只对n有规模限制，m没有，可能出现完全图的情况(每对点之间都存在一条路)这时m的规模可达$ \mathcal{O}(n^2) $，这时发现第二、三种的优化策略甚至不如朴素dijkstra，是负优化
## 7.2 整数划分
题目大意：将整数n分成k份，问有多少种方案，并将每一种方案输出
题解：是一道回溯法的搜索类题目，回溯法本身是深度优先搜索，这里的搜索层数已经给定为k，所以终止条件是层数大于k，每一步枚举范围是1到n减去已划分的数
下面是核心代码
```
void dfs(int l,int d){//l是剩下多少，d是层数
    if(d>k){
        if(l!=0)return;
        cnt++;
        for(int i=1;i<=k;i++){
            cout<<a[i];
            if(i!=k){
                cout<<" ";
            }else{
                cout<<endl;
            }
        }
        return;
    }
    for(int i=a.back();i<=l;i++){
        a.push_back(i);
        dfs(l-a.back(),d+1);
        a.pop_back();
    }
}
```
补充：
对于有部分分的比赛或考试，对于一道题目可能不会正解，那么有时就会用深度优先搜索暴力拿部分分，在搜索的过程中自然形成了一颗搜索树，而如果要使算法更快，骗更多的部分分，那么要求减少搜索树规模，俗称剪枝，即通过发现题目某些性质尽早排除掉搜索树中不必要的分支，常见剪枝方法如下
1. 优化搜索顺序
2. 可行性剪枝
3. 最优性剪枝
关于深度优先搜索大致模板
```
void dfs(....//用于枚举和判终止的参数){
    if(...)return;//终止或剪枝的条件
    ....
    if(...)return;
    for(....//枚举){
        //根据枚举量进行操作
        ....
        dfs(....)//进入递归
        //还原现场
        .....
    }
    
}
```
如果有兴趣可以尝试一下洛谷 P1120小木棍 这道题目，要拿满分需要写多达7个剪枝，(本人现在还有俩点没过。。。)
## 7.3 供电
题目大意：n个点，m条边，每个点要么花费p元自己建一个发电站，要么通过一条边连接一个已有发电站的连通块
题解：可以运用反悔的思想，一开始我们让每一个点都自己建发电站，这样花费是 $ \sum_i^np_i $
接下来我们设想如果有一条边连接两个连通块，无非两种情况1.两个连通块的发电站拆除掉其中花费较大的那个，之后再花费c将两个连通块连接 2.保留两个发电站，不去建路 比较这两个方案的花销就可以决定是方案一还是方案二
下面在思考边的枚举顺序当有两条边都能连接连通块a,b时，必然要优先让边权小的边优先被枚举，因此边的枚举顺序要保证递增
这时不难发现其实该题本质是kruskal算法，只不过并查集的代表元是集合中权值最小的点( $ p_i $)
下面是核心代码
```
for(int i=1;i<=m;i++){
        int u=way[i].u,v=way[i].v,w=way[i].w;
        int fa1=getfa(u),fa2=getfa(v);
        if(fa1==fa2)continue;
        else{
            if(p[fa2]<p[fa1]){
                if(w<p[fa1])
                    sum=sum-p[fa1]+w;//反悔，将发电站拆掉一个
                fa[fa1]=fa2;
            }
            else{
                if(w<p[fa2]){
                    sum=sum-p[fa2]+w;//反悔，将发电站拆掉一个
                }
                fa[fa2]=fa1;
            }
        }
    }
```
## 7.4 方案计数
关于求解关键节点的部分不作详细解释了，主要解释一下关键方案数的求解过程
该题是一个关于关键路径的题目，其本质还是动态规划思想的应用，简述一下动态规划思想，一个问题可以分解成多个相似子问题，当知道子问题答案后只需整合就可以得知母问题的答案（这个叫做状态转移方程），通过若干边界逐渐扩大问题规模，得到答案。在这过程中我们用一个数组储存每个子问题的答案，还要求已经求解的子问题不会受到后续求解的影响，这个性质叫做无后效性（简言之一个子问题的答案不会受到其母问题的答案影响），如果将每个子问题当成一个节点，将每个子问题与其母问题连一条单向边，这个状态图构成一个有向无环图，在求解一个问题之前我们要保证他的所有子问题都已经求解结束，那么遍历这个图的次序应该是拓扑序。
对于本题我们先设置一个虚源点(0号点)和虚汇点(n+1号点)，有利于简化代码
状态定义： $ num_i $表示从i点出发到0号点有几个关键方案数
状态转移方程应为
$$
num_u=\sum{num_v}(v表示存在v到u单向边且v为关键节点的点)
$$
遍历顺序：由上述方程可以得知在求解 $ num_u $时要求所有v节点的答案已经得出，所以是原图的拓扑序
问题的边界是 $ num_{0}=1 $
答案是： $ num_{n+1} $
下面是核心代码
```
//求拓扑序
    q.push(0);
    while(!q.empty()){
        int u=q.front();
        a.push_back(u);
        q.pop();
        for(auto v:ver1[u]){
            rd[v.first]--;
            if(rd[v.first]==0)q.push(v.first);
        }
    }
//按照拓扑序遍历状态
    num[0]=1;
    for(auto u:a){
        for(auto v:ver1[u]){
            if(dp1[v.first]==dp2[v.first])
            num[v.first]=num[u]+num[v.first];
        }
    }
```
## 7.5 最小生成树唯一性
题意：判断最小数方案是否唯一
题解：最简单直观的方法是通过kruscal算法得到一个最小生成树方案，按照这个方案找次小生成树，若次小生成树等于最小生成树，则说明最小生成树不唯一
关于得到次小生成树的算法
首先先明确次小生成树的一定是由当前这棵最小生成树，加上一条未在方案中的边，两端分别是u，v，（加上之后成环了）之后u，v在最小生成树上的路径之中删除最大边权的那条边（删边，保证依旧是棵树）
因此我们枚举所有未在方案中的边，按照上述操作，得到操作后这棵树的权值，次小生成树就是这些值里面最大的那个
朴素得到u，v在最小生成树上的路径之中删除最大边权的复杂度是$ \mathcal{O}(n) $，这样整个算法复杂度达到了$ \mathcal{O}(n^2) $，这个复杂度可以过本题,当然其实可以优化到$ \mathcal{O}(nlogn) $，见补充部分
下面是核心代码
```
    //为get函数做预处理
    function<void(int,int,int)> dfs=[&](int u,int f,int o){
        fa[u]=f;
        val[u]=o;
        dep[u]=dep[f]+1;
        for(auto v:ver[u]){
            if(v.first==f)continue;
            dfs(v.first,u,v.second);
        }
    };
    dfs(1,0,0);
    //朴素得到u，v在最小生成树上的路径之中删除最大边权
    auto get=[&](int u,int v){
        if(dep[u]>dep[v])swap(u,v);
        int k=0;
        while(dep[v]!=dep[u]){
            k=max(val[v],k);
            v=fa[v];
        }
        while(u!=v){
            k=max({k,val[u],val[v]});
            v=fa[v];
            u=fa[u];
        }
        return k;
    };
    int flag=0;
    for(int i=1;i<=m;i++){
        int u=way[i].u,v=way[i].v,w=way[i].w;
        if(mp[{u,v}])continue;//判断是否在方案中
        if(get(u,v)==w)flag=1;//判断删去的边是否跟加入的边相等
    }
```
补充：get函数优化
用到倍增思想，有兴趣可以了解一下倍增求lca(最近公共祖先)
```
function<void(int,int,int)> dfs=[&](int u,int f,int o){
        father[u][0]=f;
        val[u][0]=o;
        dep[u]=dep[f]+1;
        for(auto v:ver[u]){
            if(v.first==f)continue;
            dfs(v.first,u,v.second);
        }
    };
    dfs(1,0,0);
    for(int i=1;i<=20;i++){
        for(int j=1;j<=n;j++){
            father[j][i]=father[father[j][i-1]][i-1];
            val[j][i]=max(val[j][i-1],val[father[j][i-1]][i-1]);
        }
    }
    auto get=[&](int u,int v){
        if(dep[u]>dep[v])swap(u,v);
        int d=dep[v]-dep[u],k=0;
        for(int i=0;i<=20;i++){
            if((1<<i)&d){  
                k=max(k,val[v][i]);
                v=father[v][i];
            }
        }
        if(u==v)return k;
        for(int i=20;i>=0;i--){
            if(father[u][i]!=father[v][i]){
                k=max({k,val[v][i],val[u][i]});
                v=father[v][i],u=father[u][i];
            }
        }
        k=max({k,val[v][0],val[u][0]});
        return k;
    };
```
这个get函数的复杂度是 $ \mathcal{O}(logn) $