# 日程

## 考试时间及顺序

| 考试科目 | 考试时间 | 考试时长 |
| :--------: | :--------: | :------:|
| 近代史   | 6.16     | 一个半小时|
| 物理     | 6.18     | 两个小时 |
| 形策     | 6.22下午     |一个小时|
| 微积分   | 6.24早上     |两个小时|
| 英语     | 6.25早上     |两个小时|
| 面向对象 | 6.27早上     |两个半小时|
| 离散数学 | 6.28早上     |两个半小时|

## 复习

### 近代史

- 5.31
  - [x] 第一章
  - [x] 第二章
- 6.1
  - [x] 第三章
  - [x] 第四章
- 6.2
  - [x] 第五章
  - [x] 第六章
  - [x] 第七章
  - [x] 第八章

> 6.3号到6.10号每天看一点近代史，保证不要忘记太彻底就好，刷点客观题

- 6.11
  - [x] 第一章
  - [x] 第二章
  - [x] 做客观题
- 6.12
  - [x] 第三章
  - [x] 第四章
  - [x] 第五章
  - [x] 做客观题
- 6.13
  - [x] 第六章
  - [x] 第七章
  - [x] 第八章
  - [x] 做客观题
- 6.14
  - [x] 从头到尾背
  - [x] 做客观题
- 6.15
  - [x] 从头到尾背
  - [x] 看看客观题

> 6.15英语四级考试 6.14不强求完成任务
>
> 6.14英语
>
> 主要复习应用文（看高中笔记）
> 
> 做一套真题（重点放在阅读理解和听力）
### 物理

- 6.1 
  - [x] 简谐、机械波的题重新做
  - [x] 看简谐、机械波的课本
- 6.2、6.3、6.4、6.5
  - [x] 看电和磁的课本
  - [x] 电和磁的习题
- 6.6
  - [x] 光的课本和习题
- 6.7
  - [x] 看题
- 6.8
  - [x] 看题
- 6.9
  - [x] 一套题
> 6.14、6.15主要聚焦在近代史和英语
- 6.16
  - [x] 从头到尾回顾课本
  - [x] 看题
- 6.17
  - [x] 看错题

### 形式与政策

> 开卷考试

- 6.21
  - [x] 看形策复习材料目录和考察范围

### 微积分

> 目前发现有以下几个薄弱点
>
> 1. 对于常见积分方法遗忘（回顾笔记，课本）
> 2. 对于反常积分理解
> 3. 多重积分
> 

- 6.9
  - [x] 复习积分典例
  - [x] 反常积分复习
- 6.10
  - [x] 专题一
  - [x] 专题二
- 6.16
  - [x] 课本复习
- 6.17
  - [x] 专题三
- 6.18
  - [x] 一套题
  - [x] 专题四
- 6.19
  - [x] 一套题
- 6.20
  - [x] 一套题
- 6.21
  - [x] 一套题
- 6.22
  - [x] 一套题
- 6.23
  - [x] 错题重做

### 英语
- 6.24
  - [x] 复习英语
- 6.25
  - [x] 复习英语
### 面向对象
- 6.8
  - [x] ppt
- 6.9
  - [ ] ppt
- 6.10
  - [ ] ppt
- 6.18
  - [x] 一套题
- 6.20
  - [ ] 一套题
- 6.22
  - [ ] 一套题
- 6.24
  - [ ] 一套题
- 6.26
  - [ ] 一套题
- 6.27
  - [ ] 错题重做
### 离散数学
- 6.7
  - [x] 集合论
- 6.8
  - [x] 数理逻辑
- 6.9
  - [x] 图论
- 6.10
  - [x] 数论
- 6.18
  - [x] 一套题
- 6.19
  - [x] 一套题
- 6.20
  - [x] 一套题
- 6.21
  - [ ] 一套题
- 6.22
  - [ ] 一套题
- 6.23
  - [ ] 一套题
- 6.24
  - [ ] 一套题
- 6.25
  - [ ] 一套题
- 6.26
  - [ ] 一套题
- 6.27
  - [ ] 一套题
  - [ ] 错题回顾
## 易遗忘点
### 物理
- 波的能量密度，能流，能流密度，波强
- ==长直导线周围电场==
- ==无限大平面周围电场==

  >这两个的公式可以用高斯定理快速求
- 环形周围电场
- 电场极化强度
- 电极化率
- 电场能量（球壳电场的能量公式$E=\frac{q^2}{8 \pi \varepsilon R}$）
- 电流定义式（$I=\frac{\mathrm{d}q}{\mathrm{d}t}$）
- 毕奥——萨伐尔定律（定量解释磁感应强度和电流关系）
- ==载流长直导线磁场==
- ==载流直螺线管的磁场==

  > 可以用环路定理快速求

- ==载流圆形磁场==
- ==磁场对载流线圈的磁矩，磁力矩==
- 磁场能量
- 电磁波能量
- 光栅衍射次级小（不是很重要）
>但以上都可以现推导
- 波作业的填空倒数第二个
- 电的填空最后一个
- 电的最后一个计算
- 磁的计算第二个（求载流圆柱导体磁场用环路定理）
- 光的干涉第四个填空
- 光的填空倒数第二个（注意这种背诵题）
>比较难的题
### opp
- 注意权限的问题，权限传递的问题，不扩大权限是底线
- 指针变量（包括虚指针）和int一样都占4个字节
- 程序设计题目：
  1. 看是否可以有抽象类
  2. 明确功能所属
- 类的关系(六个关系：纵向：继承，实现接口，横向：组合(同生同死)，聚合（生死无关），依赖（成员函数用到了），关联（个体对象之间有关联）)
#### 今日的PPT查缺补漏
- 指针常量（const * ），常量指针（ * const）
- 对数组的引用```int a[10]; int (&f)[10]=a;```
- 引用要求严格类型对应(只允许里氏替换原则)
- 引用作为函数返回值无非目的就是可以让函数作左值，一是因为如果不用则返回的是一个定值，此时如果有利用该返回值再去调用别的函数可能就会发生权限的问题，二是可以让代码简洁化类似于```f(a)++;```可以出现
- inline声明必须放在定义之前
- 函数重载四个依据（即能让编译器识别该用哪一个函数）：
  1. 参数的数据类型不同
  2. 参数个数不同
  3. 参数顺序不同
  4. 参数的权限不同（这里注意记得排除```f(const int s) f(int s)```，因为这是值的传递，而非权限传递（操作s的值，不会影响实参，对实参的权限没有任何不同））:有常引用和引用，常量指针（const *）和指针，常成员函数和非常成员函数
- 函数的默认参数只允许出现在函数声明中，且靠右放
- 函数定义中允许不给形参名字```f(int ){};```前提是你确定不会用到这个形参
- ***跳过了模板***
- 类内部成员函数，有形参是自身类，则可以随意调用该形参的成员
- 嵌套类是类套类
  1. 嵌套类放在不同的地方外界对其有不同的权限
  2. 嵌套类可以访问外层类的所有成员
  3. 意义在于隐藏代码和避免头文件包含
- 不允许出现类似于```stu a（）```这样的对象声明，与函数调用重复了
- 生灭顺序
  1. 被组合类和被继承类先调用构造函数
  2. 组合关系中按照文本顺序调用构造
  3. 全局对象先于main函数
  4. 静态对象和全局对象程序结束后析构
  5. 先生后灭
- 申请对象数组时不允许调用含参数的构造函数
- 增加组合关系的构造函数调用语法后，使得常量成员和引用成员的出现成为可能
  ```
  class Student{
     const  int  i;     //此处不能赋值
     int &j;           //此处不能赋值
  public:
    Student(int s,int &k):i(s),j(k){}                
    void p(){cout<<j<<endl;}
  };
  ```
- malloc申请空间不会调用构造函数，new可以，同样free不会调用析构，而delete可以
- 当等号在定义时使用如```student a=b```这时调用重置后的拷贝函数，而如果有```student a; a=b;```此时调用的时默认拷贝函数（此时也可以由隐式类型转换）（即使已经重置）
- 类型转换：
  1. 当有构造函数```A（B b）```时类B的对象可转换成类A
  2. 强制类型转换在类A中有```operator B() ```(一定无参，而且返回值是A)可以将类A转换成类B（与1相反）
- explicit关键字，它用来修饰只有一个参数的类构造函数，以表明该构造函数是显式的，而非隐式的，该函数不允许被隐式调用（即不可利用该函数进行隐式类型转换）
- 类型转化存在二义性的例子
  ```
  class aa {
  public:
      aa(int a=1){id=a;}
      int id;
  };
  class bb {
  public:
      bb(int a=2){id=a;}
      int id;
  };
  void m(aa a){
    cout<<a.id<<endl;}
  void m(bb a){
    cout<<a.id<<endl;}
  void main(){
    m(9);  //存在二义性;
  }//转换不能太复杂，不允许多参数，不允许间接转换
  ```
- 对于类A有重置的构造函数（不管有没有参数）可以直接写成A(....(省略一下参数))，来获取一个常量对象，如果对这个常量对象赋于一个常量引用或是拷贝构造于一个对象，则当这个函数截止时才会被释放，如果没有则刚生成就会被释放
- 对于上个点为什么没有常量指针，是因为这个就类似于让一个int类型常量指针指向数字1，这是不允许的，但是引用是允许的，推广一下，这就是为什么我们可以用常引用作为形参接受非引用返回类型的函数的返回值，而不用常指针作为形参接受非引用返回类型的函数的返回值
- 小补充：&&等同于const &
- 运算符重载时的形参顺序规定了参数的出现顺序，如当定义时+（A，B）则A+B可以B+A不可以，成员函数形式第一个形参固定是该类（这个形参在定义和声明中是省略的）固有=，->等运算符只能是成员函数的意义在于这样规定好了形参的顺序防止出现6=p而实际意义是p=6的误解
- 重载运算符允许参数变少，但是不推荐这么干
- 后增加int，前增返回引用
- 只有一个对象的类
  ```
  class aa{
    static aa * aH;
      aa(){};//构造函数放在了private
      aa(aa const &){}
  public:
    static aa *get(){  if(aH == 0) aH = new aa;return(aH);}
  };
  aa * aa::aH = 0;
  
  void main(){
      aa *s = aa::get();
      aa *t = aa::get();
      aa u;//错误
  }
  ```
- 单向关联实现
  ```
  class Female;
  class Male{
       Female*  pWife;
  public:
        Male( ) {m_buffer[m_sum++] = this;}
        Female* &getWife( ) {return pWife;} 
        static  Male* m_buffer[100];  
  //存放当前产生的所有Male类对象。
        static  int m_sum;
  //其它方法及实现，略。
  };
  int Male::m_sum = 0;
  Male * Male::m_buffer[100];
  
  class Female{
       //无，去掉Male*   pHusband;
  public:
      Male * getHusband();
  // 其它定义不变
  };
  Male* Female::getHusband( ) {
    for (int i = 0; i<Male::m_sum;i++)
       if (Male::m_buffer[i]-> getWife( ) == this)
         return Male::m_buffer[i]; 
    return 0;
  }
  
  ```
- 对象可调用类中的静态成员函数和静态成员
- 静态成员内部无法调用非静态成员函数（权限放大）
- 静态成员最多被初始化一次
- 
```
class Master :public Student{
public:
   void o(Student &s){s.m1=1;//可s.m2=1;//不可s.m3=3;//不可}//视为类外
   //m1是public，m2是protected m3是private
}
  ```
- public,private,protected继承对于派生类的可见度没有变，变的是对于派生类再去派生和对外的可见度
- 继承类型省略则默认为private
- 继承中的修改权限：使using关键字（using使用的格式：using 父类名::成员名字；）注意不可以更改父类private的权限
- 组合关系不可访问private和protected（相当于类外）
- 255页的问题，类的构造函数目的是实例化与初始化立刻，故我们不能在实例化之前初始化，也不好去间断初始化
- 子类会继承父类除了构造和析构以外的所有函数
- 子类的要有自己的构造函数，而且在构造函数中如果父类没有默认的构造函数了(没有不含参的构造函数了)，子类的构造函数中要显式调用父类的构造函数，组合关系也同理，反之，则无需显式调用
- 虚函数重写时：形参，返回值，是否const都必须一致，否则不能覆盖
- 虚函数机制：给一个含有虚函数的类，储存一个虚表，每当实例化这个类时，自动给实例的个体加一个虚指针的成员
- 虚函数的析构语法就是在前面加virtual
- 构造函数、析构函数调用虚函数不支持多态,只会调用自己类中的函数
  ```
    class A {
      int x;
    public:
      virtual void f(){ cout << "父类" << endl; };
      void test(){ f(); }
      virtual ~A(){ f(); }
  };
  class B:public A {
      int y;
    public:
      void f(){ cout << "子类" << endl;  };
      void test(){ f(); }
      ~B(){ f() ;}
  };
  int main(){
      A *p = new B;                  
      delete p;
      return 0;
  }//输出是子类 父类
  //（因为析构函数是虚函数重置了，先调用的~B（），再调用的~A（））
  //（PS：这俩合起来才是对于类B的析构，就跟类B的初始化包括B（）和A（））
  ```
- 非成员、静态成员、内联函数不能是虚函数（对于内联函数，编译器会主动取消内联来实现多态，所以看起来是可以实现虚函数的）
- 构造函数放在私有，该类也不能实例化，故不能实例化的类不都是抽象类
- 抽象类语法就是写一个虚函数等于0，子类如果没重置这个函数，子类就依旧是抽象类,即使这个虚函数在父类是private中
- 
```
     virtual int p()=0 { id = 9；};//可有代码，强行访问
     ~Student(){cout<<“析构”<<endl;//析构各司其职可以纯虚但必须有代码
     //main中
        Student *q=new Mba(9);
        q->Student::p();
```
- 抽象类不可以实例对象，但是可以定义指针和引用
- 虚继承的机制：当B虚继承A，C继承B时，C不通过B来找A，而是直接与A建立通路
-  终结类
```
//终结类
class Student { 
  Student(){}
public: 
  int id; 
  friend class Master;
};
class Master :virtual public Student {
    string  pratice;
public:
    Master(){}
};
class A :public Master{};
void main(){
    Master a;                  
    A x;            //错误
}
```
机理在于，因为是虚继承，A直接与student建立通路，故A调用student的构造函数不经过Master，但是A的权限不够，因此无法实例化
- 类型转换
  1. 格式：static_cast< T >(exp)
  静态转换：等价于C语言中的强制类型转换     ( T )exp
  说明：其中 T 表示指针、引用、内置类型、枚举类型，但不能是对象。
  如:  A     *      pA = new A;
      char * pByte = static_cast<char *>(pA);
  2. 格式：const_cast< T >(exp)
  常量转换：用于添加或移除表达式中的const或volatile约束
  说明：其中 T 与exp的类型，除了const或volatile等修饰之外，必须一致
  A  *             p1 = new A;
  const A  *   const  p2 = p1;  
  const A  *             p3 = const_cast< const A  * >(p2);
  A  *   const p4 = const_cast
  A * const> (p2);
  A  *             p5 = const_cast<A *>(p2);
  3. 格式：dynamic_cast< T >(exp)
  在运行时刻，尝试将exp转换成T类型。多用于public继承下，将父类类型转换成子类类型；把基类指针（引用）转换为派生类指针（引用）因为引用不存在空引用，转换失败会抛出bad_cast异常
  1. 格式：reinterpret_cast<T>(exp)
  重新解释：对表达式的类型做出重新解释，常用于重新解释函数
  T 必须为指针、引用、整型、函数指针、成员指针           
  例：
  int    MyFunc( void * pt )  {    /*…*/  } 
  typedef  void  (* FuncType) (char *);
  FuncType  f = reinterpret_cast<FuncType >(MyFunc);
  char * buf = new char[256];
  f(buf);
  delete[ ] buf;
  
- 函数指针定义
```
  return_type (*pointer_name)(parameter_type1, parameter_type2, ...);
```
  return_type 是函数返回值的类型。
  pointer_name 是函数指针的名称。
  parameter_type1, parameter_type2, ... 是函数的参数类型。
  例：
```
  int f(int a,int b){
     cout<<"!!!!!"<<endl;
     return 1;
  };
  int main(){
      int (*p)(int,int);
      p=&f;
      p(1,1);
      return 0;
  }
```
  定义函数指针类型
```
int f(int a,int b){
     cout<<"!!!!!"<<endl;
     return 1;
};
int main(){
     typedef int (*p)(int,int);
     p a=&f;
     a(1,1);
     return 0;
}
```
- Catch只能容纳一个形参，依靠类型匹配捕获
- Catch(...)可以捕获所有的异常
- 异常处理接受里氏替换原则，除此之外要求严格满足
- <<重载
```
ostream & operator <<(ostream &out,aa &a){
   out<<a.aaa()<<a.bbb()<<endl;
   return(out);
}

```
### 微积分
- 积分典例的遗忘点：
  1. ==高阶正弦余弦积分==
  2. 由几何意义快速求积分
  3. 万能公式
  4. ==对于三角函数相除的构造法==
- 反常积分：
  难点：
  含参反常积分分类讨论收敛性（别忘了不同参数取值有的时候既要看无穷也要看点）
  方法：
  1. 先按是否看点的极限，分类讨论
  2. 不论是看无穷还是看点，去找能使收敛的参数范围
  3. 对于无穷就乘上$x^p$只要保证存在$p>1$使得极限为0到正无穷的任意常数即可
  4. 对于点的极限也类似
- 多重积分计算注意利用对称性和积分可加性，还有轮换对称性来化简
- 含参积分理解加深：对于一个不好正常方式积分出来的题目，我们可以对其进行加参或直接用式子中的参数，就是为了对函数再求偏导来实现简化函数，这样的思路有两种走法：一个是加参后变成了一元函数答案是一元函数的某一个值，我们可利用另外一个已知的函数值相减，等于导数在这个区间的积分，另一个是加参数后看成二次积分再进行换序操作
- 二元函数极限存不存在问题，几个常见的尝试路径：x和sinx，x和kx，rsinx和rcosx
- 记住导数，偏导，方向导数等还可以用定义求出
- T函数和B函数
- 偏导数的几何意义